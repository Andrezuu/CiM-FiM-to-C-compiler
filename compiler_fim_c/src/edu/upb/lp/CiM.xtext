grammar edu.upb.lp.CiM with org.eclipse.xtext.common.Terminals

generate ciM "http://www.upb.edu/lp/CiM"

Program:
	"Dear Princess Celestia:" name=ID "{"
	(attributes+=Variable | func+=Function)*
	"Today" main=Function
	"}"
	"Your faithful student," coderName=ID ".";

Function:
	"I learned" name=ID 'using'? '(' (params+=Parameter (',' params+=Parameter)*)? ')' ('with'
	returnType=Type)? "{"
	(vars+=Variable | statements+=Statement)*//| funcCalls+=FunctionCall)*
	("Then you get" returnValue=Expression)?
	"That's all about" nameClose=ID "}";

FunctionCall:
	("I would" | "I remembered")? function=[Function] 'using' '(' (args+=Expression (',' args+=Expression)*)? ')';

Parameter:
	name=ID ":" type=Type;

Type:
	"Bool" | "Int" | "String" | "Int[]" | "Bool[]";

Expression:
	NoTypeExpression | IntExpression | BooleanExpression | StringLiteral | IntArrayLiteral | BooleanArrayLiteral;

Statement:
	Print | Input | IfStatement | ForStatement | // ForEachStatement | WhileStatement | DoWhileStatement |
	VariableAssignment;

////w
//Literal:
//	BooleanLiteral | IntLiteral | StringLiteral | IntArrayLiteral | BooleanArrayLiteral;

IntLiteral:
	{IntLiteral} value=INT;

StringLiteral:
	{StringLiteral} value=STRING;

BooleanLiteral:
	{BooleanLiteral} value?=(TrueLiteral | FalseLiteral);

TrueLiteral:
	{TrueLiteral} (value?=('yes' | 'true' | 'right' | 'correct'));

FalseLiteral:
	{FalseLiteral} (value?=('no' | 'false' | 'incorrect' | 'wrong'));

IntArrayLiteral:
	'[' values+=INT (',' values+=INT)* ']';

BooleanArrayLiteral:
	'[' values+=BooleanLiteral (',' values+=BooleanLiteral)* ']';

Variable:
	("Did you know that")? name=ID
	(("is" | "was" | "has" | "had" | "like" | "likes" | "liked"))? type=Type (value=Expression)? ";";


VariableReference:
	var=[Variable];// | var=[Parameter] preguntar;

IntExpression:
	IntLiteral | MathExpression;

NoTypeExpression:
	VariableReference | FunctionCall;

MathExpression:
	Increment | Decrement | Sum | Substraction | Multiplication | Division; 

BooleanExpression:
	BooleanLiteral;//| Comparison;

Comment:
	("P.")+ "S." comment=STRING;

// OPERADORES
Increment:
	var=[Variable] "got one more";

Decrement:
	var=[Variable] "got one less";

Sum:
	("add" val1=IntExpression "and" val2=IntExpression);

Substraction:
	("substract" | "the difference between") val1=IntLiteral "and" val2=IntLiteral;

Multiplication:
	("multiply" val1=IntLiteral "and" val2=IntLiteral);

Division:
	("divide" val1=IntLiteral ("and" | "by") val2=IntLiteral);



VariableAssignment:
	VariableReference ("is now" | "are now" | "now likes" | "now like" | "become" | "becomes") value=Expression;

Print:
	"I " ("said" | "wrote" | "sang" | "thought") value=Expression ";";

Input:
	"I " ("heard" | "read" | "asked") var=[Variable] (prompt=STRING)? ";";

//COMPRACIONES
Comparison:
	Equal | NotEqual | LessThan | LessThanOrEqual | MoreThan | MoreThanOrEqual;

Comparador:
	"is" | "was" | "has" | "had";

Equal:
	Comparador "equal to" val1=Expression val2=Expression;

NotEqual:
	Comparador "not equal to" val1=Expression val2=Expression;

LessThan:
	Comparador "less than" val1=Expression val2=Expression;

LessThanOrEqual:
	Comparador "less or equal to" val1=Expression val2=Expression;

MoreThan:
	Comparador ("more" | "greater") "than" val1=Expression  val2=Expression;

MoreThanOrEqual:
	Comparador "more or equal to" val1=Expression val2=Expression;

//INSTRUCCIONES DE CONTROL DE FLUJO
//Conditional
IfStatement:
	("If" | "When") condition=BooleanExpression "then" "{"
	(vars+=Variable | statements+=Statement)* //| funcCalls+=FunctionCall)*
	("That's what I would do" | else=ElseStatement) "}";

ElseStatement:
	("Otherwise" | "Or else") "{"
	(vars+=Variable | statements+=Statement)*//| funcCalls+=FunctionCall)*
//	assigns+=VariableAssignment*
//	expr+=Expression*
	"That's what I would do" "}";

WhileStatement:
	("Here's what I did" | "As long as") condition=BooleanExpression "{"
	(vars+=Variable | statements+=Statement)*//| funcCalls+=FunctionCall)*
//	assigns+=VariableAssignment*
//	expr+=Expression*
	"That's what I did" "}";

DoWhileStatement:
	"Here's what I did" "{"
	(vars+=Variable | statements+=Statement)*//| funcCalls+=FunctionCall)*
//	assigns+=VariableAssignment*
	"}" "I did this" ("while" | "as long as") condition=BooleanExpression;

ForStatement:
	"For every" var=Variable "from" val1=(IntLiteral | VariableReference) "to"   val2=IntLiteral "{" 
	(vars+=Variable | statements+=Statement)*// | funcCalls+=FunctionCall)*
	"That's what I did" "}";

//ForEachStatement:
//	"For every" var=Variable "in" arrayValue=Literal "{"
//	vars+=Variable*
////	assigns+=VariableAssignment*
////	expr+=Expression*
//	"That's what I did"
//	"}";
